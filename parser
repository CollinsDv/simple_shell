#include "header.h"

/**
 * execute - handles process executions of commands-line arguements
 *
 * @token: pointer to the tokens
 */
void execute(char *token[], char **env)
{
	pid_t child;
	ssize_t exec_val;
	char *environment = NULL, *dup_environment = NULL, **environ_path = NULL;

	environment = _getenv("PATH", env);
	if (environment == NULL)
	{
		perror("PATH not found");
		exit(EXIT_FAILURE);
	}
	dup_environment = strdup(environment);
	printf("%s\n", dup_environment);

	environ_path = command_path(token, dup_environment);
	//for(size_t i = 0; environ_path[i] != NULL; i++)
	//	printf("%s\n", environ_path[i]);
	printf("%s\n", environ_path[0]);

	child = fork();

	if (child < 0)
	{
		perror("fork error in execute()");
		exit(EXIT_FAILURE);
	}
	else if (child == 0)
	{
		exec_val = execve(token[0], token, environ_path);
		if (exec_val < 0)
		{
			perror("./shell");
			exit(EXIT_FAILURE);
		}
	}
	else
		wait(NULL);

//	free_path(environ_path);
}

/**
 * _getenv - gets the environment PATH
 * 
 * @environment: string containing PATH string
 * @env: environment variables
 *
 * Return: pointer to PATH environment from env
 */
char *_getenv(char *environment, char **env)
{
	size_t i;

	i = 0;
	while (env[i])
	{
		if (strncmp(env[i], environment, strlen(environment)) == 0)
			return (env[i]);
		else
			i++;
	}

	return (env[i]);
}

/**
 * command_path - establishes a new command path of the command input
 *
 * @token: command table with the command in token[1]
 * @environ_path: system path
 *
 * Return: new path with command appended to system directories
 */
char **command_path(char **token, char *environ_path)
{
	char *path = NULL, **new_path = NULL;
	size_t buffer = BUFFER, position;

	new_path = malloc(sizeof(*new_path) * buffer);
	if (new_path == NULL)
	{
		perror("malloc error in command_path");
		exit(EXIT_FAILURE);
	}
	path = strtok(environ_path, ":");
	position = 0;

	while (path != NULL)
	{
		if (position >= buffer - 1)
		{
			buffer += BUFFER;

			new_path = realloc(new_path, sizeof(*new_path) * buffer);
			if (new_path == NULL)
			{
				perror("realloc error in command_path()");
				exit(EXIT_FAILURE);
			}
		}
		/*new_path[position] = malloc(strlen(path) + strlen(token[0]) + 2); * 2 to handle '/' and '\0' */
		size_t new_path_len = strlen(path) + 1 + strlen(token[0]) + 1;
		new_path[position] = malloc(new_path_len);
		if (new_path[position] == NULL)
		{
			perror("malloc error in command_path");
			exit(EXIT_FAILURE);
		}
		printf("Before strcpy: path = %s, new_path[%zu] = %s\n", path, position, new_path[position]);
		strcpy(new_path[position], path);
		printf("path copied");
		strcat(new_path[position], "/");
		printf("/ copied");
		strcat(new_path[position], token[0]);
		printf("token copied");
		strcat(new_path[position], "\0");
		position++;
		printf("%s\n", new_path[position]);
		strtok(NULL, ":");
	}
	new_path[position] = NULL;

	return (new_path);
}

/**
 * free_path - frees memory location for new command path
 *
 * @path: command path
 */
void free_path(char **path)
{
	size_t i;

	for (i = 0; path[i] != NULL; i++)
	{
		free(path[i]);
	}
	free(path);
}
